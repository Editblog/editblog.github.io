title: 蓝桥杯

-----------------------------------------------------------------------------------------------------------

# 一、实训平台介绍

## 1、实训平台布局

![](https://i.loli.net/2020/12/12/GLvQBxYMjIbczeP.jpg)![image-20201212200151324](https://i.loli.net/2020/12/12/iCwrKpEBJvtVkxG.png)

## 2、跳线帽说明

![image-20201212201215265](https://i.loli.net/2020/12/12/u2yZw5Fe4GbEQaJ.png)

## 3、电位器功能说明

![image-20201212201230347](https://i.loli.net/2020/12/12/tPqQc69IJmZTfbH.png)

## 4、输入输出接口

![ ](https://i.loli.net/2020/12/12/m1QbFfqpUYnGCSe.png)

![image-20201212201543030](https://i.loli.net/2020/12/12/rxDL1Ql43SMkVhH.png)

## 5、端口资源分配

![image-20201212201645090](https://i.loli.net/2020/12/12/34jQcSlDUegWhJr.png)

### (1)、单片机端口资源分配

![image-20201212202222329](https://i.loli.net/2020/12/12/YiKLBFe8M9PdpJT.png)

![image-20201212202236265](https://i.loli.net/2020/12/12/586FNAvIG2zgYbD.png)

![image-20201212202255282](https://i.loli.net/2020/12/12/TYxV3fIAWqRkLvd.png)

![image-20201212202517303](https://i.loli.net/2020/12/12/XTmR9CWyOS8pHsx.png)

### (2)、138译码器端口资源分配

![image-20201212202546122](https://i.loli.net/2020/12/12/xXBszSpwVqlDbG3.png)

![1](https://i.loli.net/2020/12/13/OFa2PdzpWRC13tH.png)

### (3)、锁存器端口资源分配

![image-20201212202637487](https://i.loli.net/2020/12/12/XvsGwH7FP5krVIo.png)

![image-20201212202650377](https://i.loli.net/2020/12/12/R3lP9ZfnBUgFDto.png)

### (4)、PCF8591输入端口资源分配

![image-20201212202702977](https://i.loli.net/2020/12/12/d79nwOu4rozg6Wa.png)

# 二、蜂鸣器

## 1、原理图

![image-20201213230033389](https://i.loli.net/2020/12/13/2ZixjpVKkHXJO6B.png)

## 2、代码

### (1)IO控制

```c
//简单粗暴
sbit buzzer=P0^6
P2 = 0xa0;
buzzer = 0;
P2 = 0x00;
```

```c
/*
&：与，作用是将某位置0
|：或，作用是将某位置1
且不影响其他位
*/
P2 = ((P2&0x1f)|0xa0);
P0 &= ~(0x01<<6);//关
//P0 |= (0x01<<6);//开
P2 &= 0x1f;
```

### (2)、MM控制（存储器映射）

![image-20201213232733660](https://i.loli.net/2020/12/13/6rxKMo2Yg9nRDWw.png)

```c
#include "reg52.h"
#include "absacc.h"
void main()
{
	XBYTE[0xA000] = 0x00;//关蜂鸣器
	while(1)
	{
	.......
	}
}
```

## 3、练习

### (1)、编程实现继电器控制

![image-20201214000629191](https://i.loli.net/2020/12/14/96feWsigypkuTVE.png)

```c
#include "STC15F2K60S2.h" 

sbit buzzer = P0^6;
sbit relay = P0^4;

void main()
{
	P2=0xa0;buzzer=0;P2=0x00;
	P2=0xa0;relay=1;P2=0x00;
	while(1)
	{
		
	}
}
```

### (2)、编程实现蜂鸣器间隔1秒响

（软件延时、定时器实现都可以）

```c
#include "STC15F2K60S2.h" 
#include "intrins.h"

sbit buzzer = P0^6;
sbit relay = P0^4;

void Delay1000ms()		//@11.0592MHz
{
	unsigned char i, j, k;

	_nop_();
	_nop_();
	i = 43;
	j = 6;
	k = 203;
	do
	{
		do
		{
			while (--k);
		} while (--j);
	} while (--i);
}


void main()
{
	P2=0xa0;buzzer=0;P2=0x00;
	P2=0xa0;relay=1;P2=0x00;
	while(1)
	{
		P2=0xa0;buzzer=0;P2=0x00;
		Delay1000ms();
		P2=0xa0;buzzer=1;P2=0x00;
		Delay1000ms();
	}
}
```

# 三、LED

## 1、原理图

![image-20201214002248600](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210207193509.png)

## 2、代码

### (1)、IO控制

```c
#include "STC15F2K60S2.h" 
#include "intrins.h"

void Delay200ms()		//@11.0592MHz
{
	unsigned char i, j, k;

	_nop_();
	_nop_();
	i = 9;
	j = 104;
	k = 139;
	do
	{
		do
		{
			while (--k);
		} while (--j);
	} while (--i);
}


void main()
{
	unsigned char i;
	while(1)
	{
		P2=0x80;P0=~(0x01<<i);P2=0x00;
		i++;
		if(i==8) i=0;
		Delay200ms();
	}
}




```

### (2)、MM控制



# 四、按键

![image-20210207195148284](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210207195148.png)

## 1.独立按键

### (1)状态机消抖

```C
//状态机消抖，可以用10ms延时查询，也可以用10ms中断查询，建议用中断
#define key_input P3
#define key_state_0 0	//判断按键是否按下
#define key_state_1 1	//判断按键是否抖动
#define key_state_2 2	//判断按键是否弹起
#define key_mask 0x0f	//屏蔽不需要的IO
char read_key()
{
	static key_state = 0;
	char key_press,key_return = 0;
	key_press = key_input & key_mask;
	switch(key_state)
	{
		case key_state_0:
			if(key_press != key_mask)
				key_state = key_state_1;
			break;
		
		case key_state_1:
			if(key_press != key_mask)
			{
				if(key_press == 0x0e) key_return = 1;	//S7
				if(key_press == 0x0d) key_return = 2;	//S6
				if(key_press == 0x0b) key_return = 3;	//S5
				if(key_press == 0x07) key_return = 4;	//S4
				key_state = key_state_2;
			}
			else
				key_state = key_state_0;
			break;
			
		case key_state_2:
			if(key_press == 0x0f) key_state = key_state_0;
			break;
	}
	return key_return;
}

//test
#include <STC15F2K60S2.H> 
#include "sys.h"

u8 Trg;	//触发
u8 Cont;	//持续
void main()
{
	u8 i=0;
	sys_init();
	while(1)
	{
		i = read_key();
		delay_ms(10);
		if(i == 1)
		{
			led_allon();
		}
		if(i == 2)
		{
			led_alloff();
		}
	}
		
}
```

### (2)三行代码消抖

```C
/*******************************************************
Name : key_read
Function :	(1) No Key :ReadDate=0;Trg=0;Cont=0
			(2) D0 is 0 : KEYPORT=0xfe;ReadDate=0x01;Trg = 0x01 & (0x01 ^ 0x00) = 0x01;Cont=0x01
			(3) when D0 is always 0 : Trg = 0x01 & (0x01 ^ 0x01) = 0x00;Cont=0x01
			(4) when D0 is 1 : Trg = 0x01 & (0x00 ^ 0x01) = 0;Cont=0
Example:
	if(Trg & 0x08)	//one key
	
	if(Cont & 0x08)	//long key
	{
		time_count++;
		if(time_count == 100)
		{
			time_count = 0;
			SendString(*long !\r\n);
		}
	}
*******************************************************/
extern u8 Trg;	//触发
extern u8 Cont;	//持续
void key_read()
{
	unsigned char ReadDate = KEYPORT ^ 0xff;	//ReadDate：读取的键值	^：异或	  
	Trg = ReadDate & (ReadDate ^ Cont);	//
	Cont = ReadDate;	//
}

//test
#include <STC15F2K60S2.H> 
#include "sys.h"

u8 Trg;	//触发
u8 Cont;	//持续
void main()
{
	u8 i=0;
	sys_init();
	while(1)
	{
		i = read_key();
		delay_ms(10);
		if(Trg & 0x0d)
		{
			led_allon();
		}
		if(Trg & 0x0e)
		{
			led_alloff();
		}
	}
		
}

```

## 2.矩阵按键

### 行列扫描法

先得出是哪一行的，再得出是哪一列的，如果先求列，P42与P44一直会被占用为高电平，不利于编程，会有一些bug存在

```C
#include "key.h"
#define key P3
u8 keyvalue=16;

u8 scan_key()
{
	key=0x0F;P42=0;P44=0;
	if(key!=0x0F)//说明没有按键下去  00001111
	{
		delay_ms(10);
		if(key!=0x0F)//说明没有按键下去
		{
			switch (key)
			{
				case(0x07):keyvalue=0;break;
				case(0x0b):keyvalue=1;break;
				case(0x0d):keyvalue=2;break;
				case(0x0e):keyvalue=3;break;
			}
		}
		key=0xF0;P42=1;P44=1;
		if(!P42) key=0xb0;
		if(!P44) key =0x70;
		if(key!=0xF0)
		{
			switch (key)
			{
				case(0x70):keyvalue +=0;break;
				case(0xb0):keyvalue +=4;break;
				case(0xd0):keyvalue +=8;break;
				case(0xe0):keyvalue +=12;break;
			}
		}
	}
	return keyvalue;
}

```



# 五、数码管

![image-20210207223330247](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210207223330.png)

## 1.单个数码管操作

### .h文件

```c
#ifndef __DISPALY_H__
#define __DISPALY_H__
#include "sys.h"
#define u8 unsigned char
#define u16 unsigned int
void display1(u8 yi,u8 er);
void display2(u8 san,u8 si);
void display3(u8 wu,u8 liu);
void display4(u8 qi,u8 ba);

#endif

```

### .c文件

```C
#include "display.h"
u8 code tab[]={                       //标准字库
//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
    0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,
//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y
    0x00,0x40,0x76,0x1E,0x70,0x38,0x37,0x5C,0x73,0x3E,0x78,0x3d,0x67,0x50,0x37,0x6e,
    0xBF,0x86,0xDB,0xCF,0xE6,0xED,0xFD,0x87,0xFF,0xEF,0x46};    //0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1

void display1(u8 yi,u8 er)
{
	P2=(P2&0x1f)|0xc0;//打开数码管位选573  U8
	P0=0X01;//选择第一个数码管
	P2=0XFF;//打开数码管段选573  U7
	P0=~tab[yi];//数码管显示码值
	delay_ms(1);
	 
	P2=(P2&0x1f)|0xc0;//打开数码管位选573  U8
	P0=0X02;//选择第一个数码管
	P2=0XFF;//打开数码管段选573  U7
	P0=~tab[er];//数码管显示码值
	delay_ms(1);
}
 
void display2(u8 san,u8 si)
{
	P2=(P2&0x1f)|0xc0;
	P0=0X04;
	P2=0XFF;
	P0=~tab[san];
	delay_ms(1);
	 
	P2=(P2&0x1f)|0xc0;
	P0=0X08;
	P2=0XFF;
	P0=~tab[si];
	delay_ms(1);
}
 
void display3(u8 wu,u8 liu)
{
	P2=(P2&0x1f)|0xc0;
	P0=0X10;
	P2=0XFF;
	P0=~tab[wu];
	delay_ms(1);
	 
	P2=(P2&0x1f)|0xc0;
	P0=0X20;
	P2=0XFF;
	P0=~tab[liu];
	delay_ms(1);
}
 
void display4(u8 qi,u8 ba)
{
	P2=(P2&0x1f)|0xc0;
	P0=0X40;
	P2=0XFF;
	P0=~tab[qi];
	delay_ms(1);
	 
	P2=(P2&0x1f)|0xc0;
	P0=0X80;
	P2=0XFF;
	P0=~tab[ba];
	delay_ms(1);

	P2=(P2&0x1f)|0xc0;
	P0=0XFF;
	P2=0XFF;
	P0=0XFF;
}
```

## 2.改良版

耗费一些空间，建立一个缓存区，将数值先放进缓存区，再通过定时器或者延时在固定时间内刷新一次

```C
#include "display.h"
u8 code tab[]={                       //标准字库
//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
    0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,
//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y
    0x00,0x40,0x76,0x1E,0x70,0x38,0x37,0x5C,0x73,0x3E,0x78,0x3d,0x67,0x50,0x37,0x6e,
    0xBF,0x86,0xDB,0xCF,0xE6,0xED,0xFD,0x87,0xFF,0xEF,0x46};    //0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1
u8 seg7_buf[]={10,10,17,10,10,17,10,10};

/*
	seg7set ： 将数值放到缓存中去
	@pos : 位选
	@index : 赋值的数值
*/
void seg7set(u8 pos,u8 index){
	seg7_buf[pos] = index;
}
/*
	seg7xx ：将数码管的第pos位显示为缓冲区的第index位
	@pos ： 数码管的第几位
	@index : 缓冲区的第几位
*/
void seg7xx(u8 pos,u8 index)
{
	P2 = (P2&0x1f)|0xC0;
	P0 = 1<<pos;
	P2 = P2&0x1f;

	P2 = (P2&0x1f)|0xE0;		
	P0 = ~tab[seg7_buf[index]];
	P2 = P2&0x1f;
}
```

main.c

```c
#include <STC15F2K60S2.h>
#include "sysinit.h"
#include "delay.h"
#include "LED.h"
#include "seg7.h"
u16 count=0;
u16 count10 = 0;

void main(void) {
	u16 s,min,h = 0;
	// 关闭外部设备
	Close_Buzzer();
	Led_Display(0xff);

	// 初始化中断
	Timer0Init();
	//	开启中断
	ET0 = 1;
	EA = 1;
	while(1){
		if(count10==100)
		{
			count10=0;
			s++;
		}
		// 秒
		seg7set(7,(s / 10) % 10);
		seg7set(6,s / 100);
		// 分
		if(s == 600){
			s = 0;
			min = min + 1;
		}
		seg7set(4,min % 10);
		seg7set(3,min / 10);
		// 时
		if(min == 60){
			min = 0;
			h = h + 1;
		}
		seg7set(1,h % 10);
		seg7set(0,h / 10);
	}

}

void isr_timer0() interrupt 1
{
	count++;
	count10++;
	if(count==8) count=0;
	seg7xx(count,count);
}
```

# 六、DS18B20

## 1.DS18B20温度传感器特性

![image-20210209161226879](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209161234.png)

## 2.DS18B20常见封装形式与引进说明

![image-20210209161437679](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209161437.png)

## 3、DS18B20硬件连接方式

### 1.外部电源供电方式（最常用的方式）

![image-20210209161555018](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209161555.png)

### 2.寄生电源供电方式

![image-20210209161810987](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209161811.png)

### 3.寄生电源强上拉供电方式

![image-20210209162133346](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209162133.png)

## 4、与操作DS18B20有关的內部功能结构

![image-20210209163007766](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209163007.png)

![image-20210209170316653](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209170316.png)

![image-20210209170717199](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209170717.png)

![image-20210209171354748](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209171354.png)